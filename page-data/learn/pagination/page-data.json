{"componentChunkName":"component---src-templates-doc-tsx","path":"/learn/pagination/","result":{"data":{"doc":{"frontmatter":{"title":"分页","date":null,"permalink":"/learn/pagination/","byline":null,"guestBio":null,"sublinks":null,"layout":"docs"},"id":"0001ba04-90f9-545f-8418-deef3908c174","rawMarkdownBody":"\n> 不同的分页模型可以实现不同的客户端功能\n\n在 GraphQL 中一个常见的用例是遍历对象集合之间的关系。在 GraphQL 中有许多不同的方式来展示这些关系，为客户端开发人员提供了一组不同的功能。\n\n## 复数\n\n暴露对象之间连接的最简单方法是返回一个复数类型的字段。例如，如果我们想得到一个 R2-D2 的朋友列表，我们可以直接请求所有的朋友：\n\n```graphql\n# { \"graphiql\": true }\n{\n  hero {\n    name\n    friends {\n      name\n    }\n  }\n}\n```\n\n## 切片\n\n但是，尽管如此，我们也意识到客户端可能需要其他行为。客户可能希望能够指定他们想要获取的朋友数量；也许他们只要前两个。所以我们想要暴露一些类似的东西：\n\n\n```graphql\n{\n  hero {\n    name\n    friends(first:2) {\n      name\n    }\n  }\n}\n```\n\n但即使我们仅仅获得前两个结果，我们可能仍然想要在列表中分页：一旦客户端获取前两个朋友，他们可能会发送第二个请求来请求接下来的两个朋友。我们如何启用这个行为？\n\n## 分页和边\n\n我们有很多种方法来实现分页：\n\n - 我们可以像这样 `friends(first:2 offset:2)` 来请求列表中接下来的两个结果。\n - 我们可以像这样 `friends(first:2 after:$friendId)`, 来请求我们上一次获取到的最后一个朋友之后的两个结果。\n - 我们可以像这样 `friends(first:2 after:$friendCursor)`, 从最后一项中获取一个游标并使用它来分页。\n\n一般来说，我们发现**基于游标的分页**是最强大的分页。特别当游标是不透明的时，则可以使用基于游标的分页（通过为游标设置偏移或 ID）来实现基于偏移或基于 ID 的分页，并且如果分页模型在将来发生变化，则使用游标可以提供额外的灵活性。需要提醒的是，游标是不透明的，并且它们的格式不应该被依赖，我们建议用 base64 编码它们。\n\n这导致我们遇到一个问题：我们如何从对象中获取游标？我们不希望游标放置在 `User` 类型上；它是连接的属性，而不是对象的属性。所以我们可能想要引入一个新的间接层；我们的 `friends` 字段应该给我们一个边（edge）的列表，边同时具有游标和底层节点：\n\n```graphql\n{\n  hero {\n    name\n    friends(first:2) {\n      edges {\n        node {\n          name\n        }\n        cursor\n      }\n    }\n  }\n}\n```\n\n如果存在针对于边而不是针对于某一个对象的信息，则边这个概念也被证明是有用的。例如，如果我们想要在 API 中暴露“友谊时间”，将其放置在边里是很自然的。\n\n## 列表的结尾、计数以及连接\n\n现在我们有能力使用游标对连接进行分页，但是我们如何知道何时到达连接的结尾？我们必须继续查询，直到我们收到一个空列表，但是我们真的希望连接能够告诉我们什么时候到达结尾，这样我们不需要额外的请求。同样的，如果我们想知道关于连接本身的附加信息怎么办；例如，R2-D2 有多少个朋友？\n\n为了解决这两个问题，我们的 `friends` 字段可以返回一个连接对象。连接对象将拥有一个存放边的字段以及其他信息（如总计数和有关下一页是否存在的信息）。所以我们的最终查询可能看起来像这样：\n\n\n```graphql\n{\n  hero {\n    name\n    friends(first:2) {\n      totalCount\n      edges {\n        node {\n          name\n        }\n        cursor\n      }\n      pageInfo {\n        endCursor\n        hasNextPage\n      }\n    }\n  }\n}\n```\n\n请注意，我们也可能在这个 `PageInfo` 对象中包含 `endCursor` 和 `startCursor`。这样，如果我们不需要边所包含的任何附加信息，我们就不需要查询边，因为我们从 `pageInfo` 获取了分页所需的游标。这导致连接的潜在可用性改进；相比于仅暴露 `edges` 列表，我们还可以暴露一个仅包含节点的专用列表，以避免使用间接层。\n\n## 完整的连接模型\n\n显然，这比我们原来只有复数的设计更复杂！但是通过采用这种设计，我们已经为客户解锁了许多功能：\n\n - 为列表分页的能力。\n - 请求有关连接本身的信息的能力，如 `totalCount` 或 `pageInfo`。\n - 请求有关边本身的信息的能力，如 `cursor` 或 `friendshipTime`。\n - 改变我们后端如何实现分页的能力，因为用户仅使用不透明的游标。\n\n要查看此操作，在示例 schema 中有一个附加字段，称为 `friendsConnection`，它暴露了所有这些概念。你可以在示例查询中查看它。尝试将 `after` 参数从 `friendsConnection` 移除以查看分页如何受到影响。另外，尝试用连接上的 `friends` 辅助字段替换 `edges` 字段，当适用于客户端时，这样可以直接访问朋友列表而无需额外的边这一层。\n\n```graphql\n# { \"graphiql\": true }\n{\n  hero {\n    name\n    friendsConnection(first:2 after:\"Y3Vyc29yMQ==\") {\n      totalCount\n      edges {\n        node {\n          name\n        }\n        cursor\n      }\n      pageInfo {\n        endCursor\n        hasNextPage\n      }\n    }\n  }\n}\n```\n\n## 连接规范\n\n为了确保该模式的一致实现，Relay 项目具有正式的[规范](https://facebook.github.io/relay/graphql/connections.htm)，你可以遵循该规范来构建使用基于游标的连接模式的 GraphQL API。\n"},"nextDoc":{"frontmatter":{"title":"全局对象识别","permalink":"/learn/global-object-identification/"}}},"pageContext":{"permalink":"/learn/pagination/","nextPermalink":"/learn/global-object-identification/","sideBarData":[{"name":"学习","links":[{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Introduction.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"GraphQL 入门","permalink":"/learn/","next":"/learn/queries/","category":"学习","sublinks":null,"sidebarTitle":"入门","date":null},"id":"217af6f3-a44a-5351-8b0b-a514befda9cb"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Queries.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"查询和变更","permalink":"/learn/queries/","next":"/learn/schema/","category":"学习","sublinks":"字段（Fields）,参数（Arguments）,别名（Aliases）,片段（Fragments）,操作名称（Operation Name）,变量（Variables）,指令（Directives）,变更（Mutations）,内联片段（Inline Fragments）","sidebarTitle":null,"date":null},"id":"0af86a15-fe6e-51e8-9448-8ccf0f5318ff"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Schema.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Schema 和类型","permalink":"/learn/schema/","next":"/learn/validation/","category":"学习","sublinks":"类型系统（Type System）,类型语言（Type Language）,对象类型和字段（Object Types and Fields）,参数（Arguments）,查询和变更类型（The Query and Mutation Types）,标量类型（Scalar Types）,枚举类型（Enumeration Types）,列表和非空（Lists and Non-Null）,接口（Interfaces）,联合类型（Union Types）,输入类型（Input Types）","sidebarTitle":null,"date":null},"id":"3e8d3b3c-c3e5-5aed-9f80-009e9e446f45"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Validation.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"验证","permalink":"/learn/validation/","next":"/learn/execution/","category":"学习","sublinks":null,"sidebarTitle":null,"date":null},"id":"0565a5eb-cc67-5734-ba9e-eb2c441a0f83"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Execution.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"执行","permalink":"/learn/execution/","next":"/learn/introspection/","category":"学习","sublinks":null,"sidebarTitle":null,"date":null},"id":"7e913b82-a77d-57b8-914f-31035755ef87"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Introspection.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"内省","permalink":"/learn/introspection/","next":"/learn/best-practices/","category":"学习","sublinks":null,"sidebarTitle":null,"date":null},"id":"84ba833b-73ca-5aa1-a7f7-89637e035ad9"}]},{"name":"最佳实践","links":[{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-Introduction.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"GraphQL 最佳实践","permalink":"/learn/best-practices/","next":"/learn/thinking-in-graphs/","category":"最佳实践","sublinks":null,"sidebarTitle":"介绍","date":null},"id":"c7c0e36e-a4b0-53f1-9ac7-ef52f07896f2"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-ThinkingInGraphs.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"关于 Graphs 的思考","permalink":"/learn/thinking-in-graphs/","next":"/learn/serving-over-http/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"9f665c8f-58a7-5167-a378-c25b8438940c"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-ServingOverHTTP.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"通过 HTTP 提供服务","permalink":"/learn/serving-over-http/","next":"/learn/authorization/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"7138fa24-001e-5307-b82e-da9310ea9994"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-Authorization.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"授权","permalink":"/learn/authorization/","next":"/learn/pagination/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"82fda3e7-22a0-5bac-9684-864ca66055e6"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-Pagination.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"分页","permalink":"/learn/pagination/","next":"/learn/global-object-identification/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"0001ba04-90f9-545f-8418-deef3908c174"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-NodeInterface.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"全局对象识别","permalink":"/learn/global-object-identification/","next":"/learn/caching/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"40758357-fb23-5aee-b52a-66ab6080c0a1"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-Caching.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"缓存","permalink":"/learn/caching/","next":null,"category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"7d69862f-8b98-56bc-b11e-8c532131021a"}]}],"sourcePath":"src/content/learn/BestPractice-Pagination.md"}},"staticQueryHashes":["1581580458"]}