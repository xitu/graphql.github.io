{"componentChunkName":"component---src-templates-doc-tsx","path":"/learn/caching/","result":{"data":{"doc":{"frontmatter":{"title":"缓存","date":null,"permalink":"/learn/caching/","byline":null,"guestBio":null,"sublinks":null,"layout":"docs"},"id":"7d69862f-8b98-56bc-b11e-8c532131021a","rawMarkdownBody":"\n> 提供对象的标识符以便客户端构建丰富的缓存\n\n在基于入口端点的 API 中，客户端可以使用 HTTP 缓存来确定两个资源是否相同，从而轻松避免重新获取资源。这些 API 中的 URL 是**全局唯一标识符**，客户端可以利用它来构建缓存。然而，在 GraphQL 中，没有类似 URL 的基元能够为给定对象提供全局唯一标识符。这里提供为 API 暴露这种标识符以供客户端使用的最佳实践。\n\n## 全局唯一 ID\n\n一个可行的模式是将一个字段（如 `id`）保留为全局唯一标识符。这些文档中使用的示例模式使用此方法：\n\n```graphql\n# { \"graphiql\": true }\n{\n  starship(id:\"3003\") {\n    id\n    name\n  }\n  droid(id:\"2001\") {\n    id\n    name\n    friends {\n      id\n      name\n    }\n  }\n}\n```\n\n这是向客户端开发人员提供的强大工具。与基于资源的 API 使用 URL 作为全局唯一主键的方式相同，该系统中提供 `id` 字段作为全局唯一主键。\n\n如果后端使用类似 UUID 的标识符，那么暴露这个全局唯一 ID 可能非常简单！如果后端对于每个对象并未分配全局唯一 ID，则 GraphQL 层可能需要构造此 ID。通常来说，将类型的名称附加到 ID 并将其用作标识符都很简单；服务器可能会通过 base64 编码使该 ID 不透明。\n\n可选地，此 ID 之后可以和 [全局对象标识](/learn/global-object-identification) 的 `node` 模式一起使用。\n\n## 与现有 API 的兼容\n\n为了这一目的而使用 `id` 字段的一个问题是如何让使用 GraphQL API 的客户端能够与现有的 API 并存。例如，如果我们现有的 API 接受了特定类型的 ID，但是我们的 GraphQL API 使用了全局唯一 ID，那么同时使用两者可能比较棘手。\n\n在这些情况下，GraphQL API 可以在单独的字段中暴露以前的 API 的 ID。这同时带给我们两方面的好处：\n\n - GraphQL 客户端可以继续依靠一致的机制来获取全局唯一 ID。\n - 当客户端需要使用我们以前的 API 时也可以从对象中获取 `previousApiId` 并使用它。\n\n## 备选方案\n\n虽然全局唯一 ID 在过去已经被证明是一种强大的模式，但它们并不是唯一可以使用的模式，也不适用于每种情况。客户端需要的真正关键功能是为其缓存导出全局唯一标识符的能力。服务器可以导出此 ID 以简化客户端，而客户端同样也可以导出标识符。通常，将对象的类型（通过 `__typename` 查询）与某些类型唯一标识符相结合就很简单。\n\n另外，如果使用 GraphQL API 替换现有的 API，那么如果 GraphQL 中的其他所有字段都相同，**只**更换了全局唯一的 `id`，这可能会令人困惑。这可能是为什么不选用 `id` 作为全局唯一字段的另一个原因。\n"},"nextDoc":null},"pageContext":{"permalink":"/learn/caching/","nextPermalink":null,"sideBarData":[{"name":"学习","links":[{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Introduction.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"GraphQL 入门","permalink":"/learn/","next":"/learn/queries/","category":"学习","sublinks":null,"sidebarTitle":"入门","date":null},"id":"217af6f3-a44a-5351-8b0b-a514befda9cb"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Queries.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"查询和变更","permalink":"/learn/queries/","next":"/learn/schema/","category":"学习","sublinks":"字段（Fields）,参数（Arguments）,别名（Aliases）,片段（Fragments）,操作名称（Operation Name）,变量（Variables）,指令（Directives）,变更（Mutations）,内联片段（Inline Fragments）","sidebarTitle":null,"date":null},"id":"0af86a15-fe6e-51e8-9448-8ccf0f5318ff"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Schema.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Schema 和类型","permalink":"/learn/schema/","next":"/learn/validation/","category":"学习","sublinks":"类型系统（Type System）,类型语言（Type Language）,对象类型和字段（Object Types and Fields）,参数（Arguments）,查询和变更类型（The Query and Mutation Types）,标量类型（Scalar Types）,枚举类型（Enumeration Types）,列表和非空（Lists and Non-Null）,接口（Interfaces）,联合类型（Union Types）,输入类型（Input Types）","sidebarTitle":null,"date":null},"id":"3e8d3b3c-c3e5-5aed-9f80-009e9e446f45"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Validation.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"验证","permalink":"/learn/validation/","next":"/learn/execution/","category":"学习","sublinks":null,"sidebarTitle":null,"date":null},"id":"0565a5eb-cc67-5734-ba9e-eb2c441a0f83"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Execution.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"执行","permalink":"/learn/execution/","next":"/learn/introspection/","category":"学习","sublinks":null,"sidebarTitle":null,"date":null},"id":"7e913b82-a77d-57b8-914f-31035755ef87"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Introspection.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"内省","permalink":"/learn/introspection/","next":"/learn/best-practices/","category":"学习","sublinks":null,"sidebarTitle":null,"date":null},"id":"84ba833b-73ca-5aa1-a7f7-89637e035ad9"}]},{"name":"最佳实践","links":[{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-Introduction.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"GraphQL 最佳实践","permalink":"/learn/best-practices/","next":"/learn/thinking-in-graphs/","category":"最佳实践","sublinks":null,"sidebarTitle":"介绍","date":null},"id":"c7c0e36e-a4b0-53f1-9ac7-ef52f07896f2"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-ThinkingInGraphs.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"关于 Graphs 的思考","permalink":"/learn/thinking-in-graphs/","next":"/learn/serving-over-http/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"9f665c8f-58a7-5167-a378-c25b8438940c"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-ServingOverHTTP.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"通过 HTTP 提供服务","permalink":"/learn/serving-over-http/","next":"/learn/authorization/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"7138fa24-001e-5307-b82e-da9310ea9994"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-Authorization.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"授权","permalink":"/learn/authorization/","next":"/learn/pagination/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"82fda3e7-22a0-5bac-9684-864ca66055e6"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-Pagination.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"分页","permalink":"/learn/pagination/","next":"/learn/global-object-identification/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"0001ba04-90f9-545f-8418-deef3908c174"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-NodeInterface.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"全局对象识别","permalink":"/learn/global-object-identification/","next":"/learn/caching/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"40758357-fb23-5aee-b52a-66ab6080c0a1"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-Caching.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"缓存","permalink":"/learn/caching/","next":null,"category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"7d69862f-8b98-56bc-b11e-8c532131021a"}]}],"sourcePath":"src/content/learn/BestPractice-Caching.md"}},"staticQueryHashes":["1581580458"]}