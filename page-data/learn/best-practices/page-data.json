{"componentChunkName":"component---src-templates-doc-tsx","path":"/learn/best-practices/","result":{"data":{"doc":{"frontmatter":{"title":"GraphQL 最佳实践","date":null,"permalink":"/learn/best-practices/","byline":null,"guestBio":null,"sublinks":null,"layout":"docs"},"id":"c7c0e36e-a4b0-53f1-9ac7-ef52f07896f2","rawMarkdownBody":"\nGraphQL 规范特意忽略了一些面向 API 的重要问题，例如处理网络、授权和分页。这并不意味着在使用 GraphQL 时没有针对这些问题的解决方案，只是因为它们**并非** GraphQL 定义中的一部分，可代以工程上通行的做法来实现。\n\n本章节中的文章并非不可改动的真理，在某些情况下使用其他方式可能会更加合适。其中的一些文章介绍了 Facebook 在设计和部署 GraphQL 服务的过程中的一些开发理念，而另外一些则是为解决诸如提供 HTTP 服务和执行授权等常见问题提出了更多的策略建议。\n\n以下内容是对 GraphQL 服务的一些常见的最佳实践和主观立场的简要说明，而本章节中的文章将对这些主题进行更深入的讨论。\n\n\n### HTTP\n\nGraphQL 通常通过单入口来提供 HTTP 服务的完整功能，这一实现方式与暴露一组 URL 且每个 URL 只暴露一个资源的 REST API 不同。虽然 GraphQL 也可以暴露多个资源 URL 来使用，但这可能导致您在使用 [GraphiQL](https://github.com/graphql/graphiql) 等工具时遇到困难。\n\n了解更多：[提供 HTTP 服务](/learn/serving-over-http/)。\n\n\n### JSON（使用 GZIP 压缩）\n\nGraphQL 服务通常返回 JSON 格式的数据，但 GraphQL 规范 [并未要求这一点](http://spec.graphql.org/draft/#sec-Serialization-Format)。对于期望更好的网络性能的 API 层来说，使用 JSON 似乎是一个奇怪的选择，但由于它主要是文本，因而在 GZIP 压缩后表现非常好。\n\n推荐任何在生产环境下的 GraphQL 服务都启用 GZIP，并推荐在客户端请求头中加入：\n\n```\nAccept-Encoding: gzip\n```\n\n客户端和 API 开发人员也非常熟悉 JSON，易于阅读和调试。事实上，GraphQL 语法部分地受到 JSON 语法的启发。\n\n\n### 版本控制\n\n虽然没有什么可以阻止 GraphQL 服务像任何其他 REST API 一样进行版本控制，但 GraphQL 强烈认为可以通过 GraphQL schema 的持续演进来避免版本控制。\n\n为什么大多数 API 有版本？当某个 API 入口能够返回的数据被限制，则**任何更改**都可以被视为一个破坏性变更，而破坏性变更需要发布一个新的版本。如果向 API 添加新功能需要新版本，那么在经常发布版本并拥有许多增量版本与保证 API 的可理解性和可维护性之间就需要权衡。\n\n相比之下，GraphQL 只返回显式请求的数据，因此可以通过增加新类型和基于这些新类型的新字段添加新功能，而不会造成破坏性变更。这样可以衍生出始终避免破坏性变更并提供无版本 API 的通用做法。\n\n\n### 可以为空的性质\n\n大多数能够识别 “null” 的类型系统都提供普通类型和该类型**可以为空**的版本，默认情况下，类型不包括 “null”，除非明确声明。但在 GraphQL 类型系统中，默认情况下每个字段都**可以为空**。这是因为在由数据库和其他服务支持的联网服务中可能会出现许多问题，比如数据库可能会宕机，异步操作可能会失败，异常可能会被抛出。除了系统故障之外，授权通常可以是细粒度的，请求中的各个字段可以具有不同的授权规则。\n\n通过默认设置每个字段**可以为空**，以上任何原因都可能导致该字段返回 “null”，而不是导致请求完全失败。作为替代，GraphQL 提供 [non-null](/learn/schema/#lists-and-non-null) 这一变体类型来保证当客户端发出请求时，该字段永远不会返回 “null”。相反，如果发生错误，则上一个父级字段将为 “null”。\n\n在设计 GraphQL schema 时，请务必考虑所有可能导致错误的情况下，“null” 是否可以作为获取失败的字段合理的返回值。通常它是，但偶尔，它不是。在这种情况下，请使用非空类型进行保证。\n\n\n### 分页\n\nGraphQL 类型系统允许某些字段返回 [值的列表](/learn/schema/#lists-and-non-null)，但是为长列表分页的功能则交给 API 设计者自行实现。为 API 设计分页功能有很多种各有利弊的方案。\n\n通常当字段返回长列表时，可以接收参数 “first” 和 “after” 来指定列表的特定区域，其中 “after” 是列表中每个值的唯一标识符。\n\n最终在具有功能丰富的分页的 API 设计中，衍生出一种称为 “Connections” 的最佳实践模式。GraphQL 的一些客户端工具（如 [Relay](https://facebook.github.io/relay/)）采用了 Connections 模式，当 GraphQL API 使用此模式时，可以自动为客户端分页提供支持。\n\n了解更多：[分页](/learn/pagination/)。\n\n\n### 服务器端的批处理与缓存\n\nGraphQL 的设计方式便于您在服务器上编写整洁的代码，每种类型的每个字段都有一个专用且目标唯一的函数来解析该值。然而当考虑不完善时，一个过于简单的 GraphQL 服务可能会像 “聊天” 一样反复从您的数据库加载数据。\n\n这通常可以通过批处理技术来解决，这一技术能够收集短时间内来自后端的多个数据请求，然后通过诸如 Facebook 的 [DataLoader](https://github.com/facebook/dataloader) 等工具，将其打包成单个请求再发送到底层数据库或微服务。\n"},"nextDoc":{"frontmatter":{"title":"关于 Graphs 的思考","permalink":"/learn/thinking-in-graphs/"}}},"pageContext":{"permalink":"/learn/best-practices/","nextPermalink":"/learn/thinking-in-graphs/","sideBarData":[{"name":"学习","links":[{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Introduction.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"GraphQL 入门","permalink":"/learn/","next":"/learn/queries/","category":"学习","sublinks":null,"sidebarTitle":"入门","date":null},"id":"217af6f3-a44a-5351-8b0b-a514befda9cb"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Queries.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"查询和变更","permalink":"/learn/queries/","next":"/learn/schema/","category":"学习","sublinks":"字段（Fields）,参数（Arguments）,别名（Aliases）,片段（Fragments）,操作名称（Operation Name）,变量（Variables）,指令（Directives）,变更（Mutations）,内联片段（Inline Fragments）","sidebarTitle":null,"date":null},"id":"0af86a15-fe6e-51e8-9448-8ccf0f5318ff"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Schema.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"Schema 和类型","permalink":"/learn/schema/","next":"/learn/validation/","category":"学习","sublinks":"类型系统（Type System）,类型语言（Type Language）,对象类型和字段（Object Types and Fields）,参数（Arguments）,查询和变更类型（The Query and Mutation Types）,标量类型（Scalar Types）,枚举类型（Enumeration Types）,列表和非空（Lists and Non-Null）,接口（Interfaces）,联合类型（Union Types）,输入类型（Input Types）","sidebarTitle":null,"date":null},"id":"3e8d3b3c-c3e5-5aed-9f80-009e9e446f45"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Validation.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"验证","permalink":"/learn/validation/","next":"/learn/execution/","category":"学习","sublinks":null,"sidebarTitle":null,"date":null},"id":"0565a5eb-cc67-5734-ba9e-eb2c441a0f83"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Execution.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"执行","permalink":"/learn/execution/","next":"/learn/introspection/","category":"学习","sublinks":null,"sidebarTitle":null,"date":null},"id":"7e913b82-a77d-57b8-914f-31035755ef87"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/Learn-Introspection.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"内省","permalink":"/learn/introspection/","next":"/learn/best-practices/","category":"学习","sublinks":null,"sidebarTitle":null,"date":null},"id":"84ba833b-73ca-5aa1-a7f7-89637e035ad9"}]},{"name":"最佳实践","links":[{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-Introduction.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"GraphQL 最佳实践","permalink":"/learn/best-practices/","next":"/learn/thinking-in-graphs/","category":"最佳实践","sublinks":null,"sidebarTitle":"介绍","date":null},"id":"c7c0e36e-a4b0-53f1-9ac7-ef52f07896f2"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-ThinkingInGraphs.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"关于 Graphs 的思考","permalink":"/learn/thinking-in-graphs/","next":"/learn/serving-over-http/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"9f665c8f-58a7-5167-a378-c25b8438940c"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-ServingOverHTTP.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"通过 HTTP 提供服务","permalink":"/learn/serving-over-http/","next":"/learn/authorization/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"7138fa24-001e-5307-b82e-da9310ea9994"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-Authorization.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"授权","permalink":"/learn/authorization/","next":"/learn/pagination/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"82fda3e7-22a0-5bac-9684-864ca66055e6"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-Pagination.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"分页","permalink":"/learn/pagination/","next":"/learn/global-object-identification/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"0001ba04-90f9-545f-8418-deef3908c174"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-NodeInterface.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"全局对象识别","permalink":"/learn/global-object-identification/","next":"/learn/caching/","category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"40758357-fb23-5aee-b52a-66ab6080c0a1"},{"fileAbsolutePath":"/home/runner/work/graphql.github.io/graphql.github.io/src/content/learn/BestPractice-Caching.md","parent":{"relativeDirectory":"learn","sourceInstanceName":"content"},"frontmatter":{"title":"缓存","permalink":"/learn/caching/","next":null,"category":"最佳实践","sublinks":null,"sidebarTitle":null,"date":null},"id":"7d69862f-8b98-56bc-b11e-8c532131021a"}]}],"sourcePath":"src/content/learn/BestPractice-Introduction.md"}},"staticQueryHashes":["1581580458"]}